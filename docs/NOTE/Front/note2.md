---

hideFooter: true

---
# vue实现路由权限总结 #

::: tip 契子
- 路由权限总结
:::

## &01.使用全局路由守卫 ##

参考iview-admin的实现方式：

- 给每一个菜单定义权限，每次跳转之前，全局路由守卫都会对其进行判断，菜单列表根据用户权限把路由过滤一遍生成。判断是否登录/是否符合权限，进行相关处理

缺点：
1.如果路由很多，用户并不是所有路由都有权限访问，对性能有影响。全局守卫那里，每次菜单跳转，都要做相应的判断

2.菜单信息写死在前端，每次修改还要重新编译

## &02.使用addRoutes实现方式 ##

参考vue-element-admin

- 获取用户信息，筛选有权限访问的路由，再调用addRoutes添加新的路由

缺点：
同上2

## &03.路由和菜单分离 ##

参考vue-quasar-admin

- 因菜单icon/菜单名称随时可能修改，后端直接根据用户的权限返回相关的菜单列表。前端在全局路由守卫里面判断，因为菜单的name与路由的name是一一对应的,而后端返回的菜单就已经是经过权限过滤的，所以如果根据路由name找不到对应的菜单，就表示用户有没权限访问。如果路由太多，也可以先挂载不需要权限的路由，再用addRoutes挂载路由

缺点：
1.如果添加了新的菜单，后端和前端都要约定好菜单的路由信息，否则会影响正常功能使用

2.全局守卫依然要做判断

## &04.菜单和路由都由后端控制 ##

1.建议把菜单和路由分开处理，因为菜单可能存在多级，经常会出现多级遍历路由为了拼接菜单的情况。

2.需要前后端的高级配合。后端返回一个菜单列表和一个路由列表，前端需要的信息都返回。但是这里需要注意，前后端一定要约定好路由组件的路径等信息。

3.维护一份routerMapComponents.js文件，使用key-value的形式，方便管理后端返回的路由数据。映射到组件上

4.对于异步组件的处理

```bash
route.component = function (resolve) {
    require([`../${route.componentPath}.vue`], resolve)
}
```
参考：
https://juejin.im/post/5c0b2130f265da615c5913d9

https://juejin.im/post/5c30c666518825261c1b7191


