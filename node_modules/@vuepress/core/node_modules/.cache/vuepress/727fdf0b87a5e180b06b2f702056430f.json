{"remainingRequest":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/@vuepress/markdown-loader/index.js??ref--1-2!/Users/xiaohanghang/Desktop/front/code/zh-doc/docs/NOTE/vue.md?vue&type=template&id=5585ddde&","dependencies":[{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/docs/NOTE/vue.md","mtime":1582983449000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/cache-loader/dist/cjs.js","mtime":1581571682000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1581571684000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/cache-loader/dist/cjs.js","mtime":1581571682000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/index.js","mtime":1581571684000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/@vuepress/markdown-loader/index.js","mtime":1581571682000}],"contextDependencies":[],"result":["\n<ContentSlotsDistributor :slot-key=\"$parent.slotKey\"><h1 id=\"vue面试题总结\"><a class=\"header-anchor\" href=\"#vue面试题总结\" aria-hidden=\"true\">#</a> vue面试题总结</h1>\n<div class=\"tip custom-block\"><p class=\"custom-block-title\">契子</p>\n<ul>\n<li>https://juejin.im/post/5e50f5e0f265da5709701cc8</li>\n</ul>\n</div>\n<h2 id=\"_01-v-show和v-if的区别\"><a class=\"header-anchor\" href=\"#_01-v-show和v-if的区别\" aria-hidden=\"true\">#</a> &amp;01.v-show和v-if的区别</h2>\n<h2 id=\"_02-为何v-for需要key\"><a class=\"header-anchor\" href=\"#_02-为何v-for需要key\" aria-hidden=\"true\">#</a> &amp;02.为何v-for需要key</h2>\n<ul>\n<li>v-for的key最好不要用random或者index</li>\n<li>v-for和v-if不能一起使用</li>\n<li>遍历对象可以使用v-for</li>\n</ul>\n<h2 id=\"_03-事件\"><a class=\"header-anchor\" href=\"#_03-事件\" aria-hidden=\"true\">#</a> &amp;03.事件</h2>\n<ul>\n<li>【观察】事件被绑定到哪里</li>\n<li>事件修饰符，按键修饰符</li>\n<li>event参数，自定义参数\nvue对象本身就可以实现eventBus的功能，用于兄弟组件之间传值。$emit传递事件，$on接受事件，接受之后必须在beforeDestroy中使用$off及时销魂事件，否则可能会造成内存泄漏</li>\n</ul>\n<h2 id=\"_04-生命周期\"><a class=\"header-anchor\" href=\"#_04-生命周期\" aria-hidden=\"true\">#</a> &amp;04.生命周期</h2>\n<ul>\n<li>挂载阶段\n1、created和mounted有什么区别？</li>\n</ul>\n<p>created指实例初始化完成，页面还没有开始渲染；mounted指页面渲染完成，数据已挂载到页面上；</p>\n<ul>\n<li>\n<p>更新阶段</p>\n</li>\n<li>\n<p>销毁阶段\n解除绑定自定义事件、销毁子组件以及监听器</p>\n</li>\n<li>\n<p>生命周期（父子组件）\n父created=》子组件created=》子组件mounted=》父组件mounted：先保证子组件渲染完，再渲染子组件</p>\n</li>\n</ul>\n<h2 id=\"_05-vue高级特性\"><a class=\"header-anchor\" href=\"#_05-vue高级特性\" aria-hidden=\"true\">#</a> &amp;05.vue高级特性</h2>\n<ul>\n<li>自定义v-model</li>\n<li>$nextTick/refs</li>\n<li>slot</li>\n<li>动态、异步组件</li>\n<li>keep-alive</li>\n<li>mixin</li>\n</ul>\n<h2 id=\"_06-vue高级特性一-v-model\"><a class=\"header-anchor\" href=\"#_06-vue高级特性一-v-model\" aria-hidden=\"true\">#</a> &amp;06.vue高级特性一  v-model</h2>\n<ul>\n<li>input标签中，@input(v-on:input)input框中输入每个字符都会调用这个事件，多用来做实时查询</li>\n</ul>\n<h2 id=\"_07-vue高级特性一-nexttick\"><a class=\"header-anchor\" href=\"#_07-vue高级特性一-nexttick\" aria-hidden=\"true\">#</a> &amp;07.vue高级特性一  $nextTick</h2>\n<ul>\n<li>vue是异步渲染：data改变之后，dom不会立刻渲染</li>\n<li>$nextTick会在DOM渲染之后被触发，以获取最新DOM节点</li>\n<li>页面渲染时会将data的数据做整合，多次data修改只会渲染一次</li>\n</ul>\n<h2 id=\"_07-vue高级特性一-slot\"><a class=\"header-anchor\" href=\"#_07-vue高级特性一-slot\" aria-hidden=\"true\">#</a> &amp;07.vue高级特性一  slot</h2>\n<ul>\n<li>具名插槽、作用域插槽\n作用域插槽：父组件可以获取子组件slot定义的数据，v-slot</li>\n</ul>\n<h2 id=\"_08-vue高级特性一-动态组件\"><a class=\"header-anchor\" href=\"#_08-vue高级特性一-动态组件\" aria-hidden=\"true\">#</a> &amp;08.vue高级特性一  动态组件</h2>\n<ul>\n<li>:is=&quot;component-name&quot;</li>\n</ul>\n<h2 id=\"_08-vue高级特性一-异步组件\"><a class=\"header-anchor\" href=\"#_08-vue高级特性一-异步组件\" aria-hidden=\"true\">#</a> &amp;08.vue高级特性一  异步组件</h2>\n<ul>\n<li>import函数</li>\n<li>按需加载，异步加载大组件</li>\n</ul>\n<!--beforebegin--><div class=\"language-bash line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code>components: <span class=\"token punctuation\">{</span>\n    FormDemo: <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> import<span class=\"token punctuation\">(</span><span class=\"token string\">'XXXX'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend--><h2 id=\"_08-vue高级特性一-缓存组件\"><a class=\"header-anchor\" href=\"#_08-vue高级特性一-缓存组件\" aria-hidden=\"true\">#</a> &amp;08.vue高级特性一  缓存组件</h2>\n<ul>\n<li>keep-alive：vue层级控制，js对象</li>\n<li>频繁切换，不需要重复渲染</li>\n<li>vue常见性能优化：异步组件、缓存组件、webpack</li>\n</ul>\n<h2 id=\"_09-vue高级特性一-mixin，抽离公共组件\"><a class=\"header-anchor\" href=\"#_09-vue高级特性一-mixin，抽离公共组件\" aria-hidden=\"true\">#</a> &amp;09.vue高级特性一  mixin，抽离公共组件</h2>\n<ul>\n<li>多个组件有相同的逻辑，抽离出来</li>\n<li>Vue3 提出的composition API旨在解决这些问题</li>\n</ul>\n<p>问题：</p>\n<ol>\n<li>\n<p>代码来源不明确，不利于阅读</p>\n</li>\n<li>\n<p>多个mixin可能会出现命名冲突</p>\n</li>\n<li>\n<p>关系复杂</p>\n</li>\n</ol>\n<h2 id=\"_010-vuex的使用\"><a class=\"header-anchor\" href=\"#_010-vuex的使用\" aria-hidden=\"true\">#</a> &amp;010. vuex的使用##</h2>\n<ul>\n<li>考察state的基本结构设计</li>\n</ul>\n<h2 id=\"_011-vue-router\"><a class=\"header-anchor\" href=\"#_011-vue-router\" aria-hidden=\"true\">#</a> &amp;011. vue-router##</h2>\n<ul>\n<li>路由模式（hash、h5 history）</li>\n<li>路由配置（动态路由、懒加载）</li>\n</ul>\n<h2 id=\"_012-vue原理\"><a class=\"header-anchor\" href=\"#_012-vue原理\" aria-hidden=\"true\">#</a> &amp;012. vue原理</h2>\n<ul>\n<li>组件化</li>\n<li>响应式</li>\n<li>vdom和diff</li>\n<li>模版编译</li>\n<li>渲染过程</li>\n<li>前端路由</li>\n</ul>\n<h2 id=\"_013-vue响应式\"><a class=\"header-anchor\" href=\"#_013-vue响应式\" aria-hidden=\"true\">#</a> &amp;013. vue响应式</h2>\n<p>组件data的数据一旦变化，立刻触发视图的更新</p>\n<p>核心API-Object.defineProperty</p>\n<ul>\n<li>如何实现响应式</li>\n<li>缺点（Vue3.0启用Proxy）</li>\n</ul>\n<p>Object.defineProperty缺点</p>\n<pre><code>1）深度监听，需要递归到底，一次性计算量大\n\n2）无法监听新增属性/删除属性（Vue.set Vue.delete）\n\n3）无法原生监听数组，需要特殊处理\n</code></pre>\n<!--beforebegin--><div class=\"language-bash line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code>    const data <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">'name'</span><span class=\"token keyword\">:</span> <span class=\"token string\">'zzz'</span>,\n        <span class=\"token string\">'age'</span><span class=\"token keyword\">:</span> <span class=\"token string\">'21'</span>,\n        <span class=\"token string\">'info'</span><span class=\"token keyword\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">'address'</span><span class=\"token keyword\">:</span> <span class=\"token string\">'city'</span>,  //属于深度监听\n        <span class=\"token punctuation\">}</span>,\n        <span class=\"token string\">'arr'</span><span class=\"token keyword\">:</span> <span class=\"token punctuation\">[</span>1,2,3<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n\n\t//重新定义数组原型\n\tconst oldArrayProperty <span class=\"token operator\">=</span> Array.prototype<span class=\"token punctuation\">;</span>\n\t//创建新对象，扩展新方法不会影响原型\n\tconst arrProto <span class=\"token operator\">=</span> Object.create<span class=\"token punctuation\">(</span>oldArrayProperty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">[</span><span class=\"token string\">'push'</span>, <span class=\"token string\">'pop'</span>, <span class=\"token string\">'shift'</span>, <span class=\"token string\">'unshift'</span>, <span class=\"token string\">'splice'</span><span class=\"token punctuation\">]</span>.forEach<span class=\"token punctuation\">(</span>methodName <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n\t\tarrProto<span class=\"token punctuation\">[</span>methodName<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> function<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tupdateView<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  //触发视图更新\n\t\t\toldArrayProperty<span class=\"token punctuation\">[</span>methodName<span class=\"token punctuation\">]</span>.call<span class=\"token punctuation\">(</span>this, <span class=\"token punctuation\">..</span>.arguments<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n\t//监听对象属性\n\t<span class=\"token keyword\">function</span> observer<span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tif<span class=\"token punctuation\">(</span>typeof target <span class=\"token operator\">!=</span><span class=\"token operator\">=</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">||</span> target <span class=\"token operator\">==</span><span class=\"token operator\">=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t//不是对象或数组\n\t\t\t<span class=\"token keyword\">return</span> target\n\t\t<span class=\"token punctuation\">}</span>\n\t\t//\n\t\tif<span class=\"token punctuation\">(</span>Array.isArray<span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">))</span> <span class=\"token punctuation\">{</span>\n\t\t\ttarget.__proto__ <span class=\"token operator\">=</span> arrProto<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t//重新定义各个属性\n\t\tfor<span class=\"token punctuation\">(</span>let key <span class=\"token keyword\">in</span> target<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tdefineReactive<span class=\"token punctuation\">(</span>target, key, target<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t//监听对象\n\t<span class=\"token keyword\">function</span> defineReactive<span class=\"token punctuation\">(</span>target, key, value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t//深度监听\n\t\tobserver<span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t//核心API\n\t\tObject.defineProperty<span class=\"token punctuation\">(</span>target, key, <span class=\"token punctuation\">{</span>\n\t\t\tget<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token keyword\">return</span> value\n\t\t\t<span class=\"token punctuation\">}</span>,\n\t\t\tset<span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\tif<span class=\"token punctuation\">(</span>newValue <span class=\"token operator\">!=</span><span class=\"token operator\">=</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t\t//设置新值--深度监听\n\t\t\t\t\tobserver<span class=\"token punctuation\">(</span>newValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t\t\t\tvalue <span class=\"token operator\">=</span> newValue<span class=\"token punctuation\">;</span>\n\t\t\t\t\t//触发更新视图\n\t\t\t\t\tupdateView<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\t\t<span class=\"token punctuation\">}</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t//视图更新\n\t<span class=\"token keyword\">function</span> updateView<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tconsole.log<span class=\"token punctuation\">(</span><span class=\"token string\">'触发更新视图'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n\n\tobserver<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tconsole.log<span class=\"token punctuation\">(</span>data.name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t// data.age <span class=\"token operator\">=</span> <span class=\"token string\">'10'</span><span class=\"token punctuation\">;</span>\n\tdata.arr.push<span class=\"token punctuation\">(</span><span class=\"token string\">'333'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   //数组触发\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br><span class=\"line-number\">12</span><br><span class=\"line-number\">13</span><br><span class=\"line-number\">14</span><br><span class=\"line-number\">15</span><br><span class=\"line-number\">16</span><br><span class=\"line-number\">17</span><br><span class=\"line-number\">18</span><br><span class=\"line-number\">19</span><br><span class=\"line-number\">20</span><br><span class=\"line-number\">21</span><br><span class=\"line-number\">22</span><br><span class=\"line-number\">23</span><br><span class=\"line-number\">24</span><br><span class=\"line-number\">25</span><br><span class=\"line-number\">26</span><br><span class=\"line-number\">27</span><br><span class=\"line-number\">28</span><br><span class=\"line-number\">29</span><br><span class=\"line-number\">30</span><br><span class=\"line-number\">31</span><br><span class=\"line-number\">32</span><br><span class=\"line-number\">33</span><br><span class=\"line-number\">34</span><br><span class=\"line-number\">35</span><br><span class=\"line-number\">36</span><br><span class=\"line-number\">37</span><br><span class=\"line-number\">38</span><br><span class=\"line-number\">39</span><br><span class=\"line-number\">40</span><br><span class=\"line-number\">41</span><br><span class=\"line-number\">42</span><br><span class=\"line-number\">43</span><br><span class=\"line-number\">44</span><br><span class=\"line-number\">45</span><br><span class=\"line-number\">46</span><br><span class=\"line-number\">47</span><br><span class=\"line-number\">48</span><br><span class=\"line-number\">49</span><br><span class=\"line-number\">50</span><br><span class=\"line-number\">51</span><br><span class=\"line-number\">52</span><br><span class=\"line-number\">53</span><br><span class=\"line-number\">54</span><br><span class=\"line-number\">55</span><br><span class=\"line-number\">56</span><br><span class=\"line-number\">57</span><br><span class=\"line-number\">58</span><br><span class=\"line-number\">59</span><br><span class=\"line-number\">60</span><br><span class=\"line-number\">61</span><br><span class=\"line-number\">62</span><br><span class=\"line-number\">63</span><br><span class=\"line-number\">64</span><br><span class=\"line-number\">65</span><br><span class=\"line-number\">66</span><br><span class=\"line-number\">67</span><br><span class=\"line-number\">68</span><br></div><!--beforeend--></div><!--afterend--><h2 id=\"_013-虚拟dom和diff\"><a class=\"header-anchor\" href=\"#_013-虚拟dom和diff\" aria-hidden=\"true\">#</a> &amp;013. 虚拟DOM和diff</h2>\n<ul>\n<li>\n<p>vdom是实现vue和react的重要基石\nvdom-用JS模拟DOM结构，计算出最小的变更，操作DOM</p>\n</li>\n<li>\n<p>diff算法是vdom中最核心、最关键的部分--时间复杂度O(n)\n1）只比较同一层级，不跨级比较</p>\n<p>2）tag不相同，则直接删除重建，不再深度比较</p>\n<p>3）tag和key，两者都相同，则认为是相同节点，不再深度比较</p>\n</li>\n</ul>\n<h2 id=\"_014-模板编译\"><a class=\"header-anchor\" href=\"#_014-模板编译\" aria-hidden=\"true\">#</a> &amp;014. 模板编译</h2>\n<ul>\n<li>with函数，\n使用with，能改变{}内自由变量的查找方式，当作obj的属性来查找</li>\n</ul>\n<h2 id=\"_015-vue面试\"><a class=\"header-anchor\" href=\"#_015-vue面试\" aria-hidden=\"true\">#</a> &amp;015. vue面试</h2>\n<ul>\n<li>\n<p>为何在v-for中使用key\n必须用key，且不能是indx和random；diff算法中通过tag和key来判断，是否是sameNode；\n高效的更新虚拟DOM，提高性能</p>\n<p>就地复用策略：列表数据修改的时候，他会根据key值去判断某个值是否修改，如果修改，则会重新渲染这一项，否则复用之前的元素；</p>\n<p>不建议使用index；场景：v-for一个数组，如果中途插入一个元素，会改变这个元素之后的key值，造成无意义的渲染。建议用id这种不会变的值作为key</p>\n</li>\n<li>\n<p>双向数据绑定v-model的实现</p>\n</li>\n<li>\n<p>对mvvm的理解</p>\n</li>\n<li>\n<p>computed有何特点\n缓存，data不会不会重新计算，提高性能</p>\n</li>\n<li>\n<p>为何组件data必须是一个函数\n定义的.vue最后是一个类，每次使用.vue是使用一个实例化，data必须是一个函数，形成闭包，对外不可见，也是为了不被污染</p>\n</li>\n<li>\n<p>ajax请求应该放在哪个生命周期\nmounted中，dom加载完成之后</p>\n</li>\n<li>\n<p>何时需要使用beforeDestory\n解除自定义事件event.$off，清除定时器，解除自定义的DOM事件，如window scroll等</p>\n</li>\n<li>\n<p>vue如何监听数组变化\nObject.defineProperty 不能监听数组变化；重新定义原型，重写push pop等方法，实现监听；Proxy可以原生支持监听数组变化</p>\n</li>\n<li>\n<p>请描述响应式原理\n监听data变化；组件渲染和更新的过程</p>\n</li>\n<li>\n<p>Vue为何是异步渲染，$nextTick何用\n异步渲染（以及合并data修改），以提高渲染性能；$nextTick在DOM更新完以后，触发回调</p>\n</li>\n<li>\n<p>Vue常见性能优化方式\n1、合理使用v-show和v-if</p>\n</li>\n</ul>\n<p>2、合理使用computed</p>\n<p>3、v-for中加key，以及避免和v-if的使用；因为v-for的优先级要高一些，每次循环之后指向v-if性能会下降</p>\n<p>4、自定义事件、DOM事件及时销毁</p>\n<p>5、合理使用异步组件</p>\n<p>6、合理使用keep-alive</p>\n<p>7、data层级不要太深--vue内部data监听相关</p>\n<p>8、使用vue-loader在开发环境做模版预编译</p>\n<p>9、webpack层面的优化</p>\n<h2 id=\"_016-vue-初次渲染-更新过程\"><a class=\"header-anchor\" href=\"#_016-vue-初次渲染-更新过程\" aria-hidden=\"true\">#</a> &amp;016. vue 初次渲染/更新过程</h2>\n<ul>\n<li>初次渲染过程</li>\n</ul>\n<ol>\n<li>\n<p>解析模版为render函数（或在开发环境已完成，vue-loader）</p>\n</li>\n<li>\n<p>触发响应式，监听data属性getter setter</p>\n</li>\n<li>\n<p>执行render函数，生成vnode，patch（elem，vnode）</p>\n</li>\n</ol>\n<ul>\n<li>更新过程</li>\n</ul>\n<ol>\n<li>\n<p>修改data，触发setter（此前在getter中已被监听）</p>\n</li>\n<li>\n<p>重新执行render函数，生成newVnode</p>\n</li>\n<li>\n<p>patch(vnode, newVnode)</p>\n</li>\n</ol>\n<h2 id=\"_017-vue的生命周期\"><a class=\"header-anchor\" href=\"#_017-vue的生命周期\" aria-hidden=\"true\">#</a> &amp;017. vue的生命周期</h2>\n<ul>\n<li>beforeCreate（创建前）：在数据观测和初始化事件还未开始</li>\n<li>created（创建后）：完成数据观测、属性和方法的运算，初始化事件，$el属性还没有显示出来</li>\n<li>beforeMount（载入前）：在挂载之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板、把data里面的数据和模板生成html。注意此时还没有挂载到html页面上</li>\n<li>mounted（载入后）：vm.$el挂载到实例上调用。实例已完成以下：用编译好的html内容替换el属性指向的DOM对象，完成模板中的html渲染到页面上；</li>\n<li>beforeUpdate（更新前）：在数据更新之前调用</li>\n<li>updated（更新后）：组件DOM已经更新</li>\n<li>beforeDestory（销毁前）</li>\n<li>bestoryed（销毁后）</li>\n</ul>\n<p>生命周期的作用：它的生命周期有多个事件钩子，让我们在控制整个VUE实例的过程中更容易形成好的逻辑</p>\n<h2 id=\"_018-vue实现数据双向绑定的原理\"><a class=\"header-anchor\" href=\"#_018-vue实现数据双向绑定的原理\" aria-hidden=\"true\">#</a> &amp;018. vue实现数据双向绑定的原理</h2>\n<p>主要：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty来劫持各个属性的setter，getter</p>\n<p>过程：</p>\n<ol>\n<li>\n<p>当初始化vue data时，vue将遍历它的每一个属性，用Object.defineProperty将他们转为getter、setter</p>\n</li>\n<li>\n<p>当只想data 的get时，会将此属性加入到依赖收集当中，如果下次此属性setter触发变化，监听会通知watcher，从而更新视图</p>\n</li>\n</ol>\n<p>注意：object.defineProperty监听不了数组 ，vue里面重写了数组方法达到监听效果</p>\n<p>检测变化的注意事项：Vue无法检测到对象属性的添加或删除，由于Vue会在初始化实例时对属性执行getter/setter转化，所以属性必须在data对象上才能让vue将它转为响应式；如果需要，使用Vue.set/delete</p>\n<!--beforebegin--><div class=\"language-bash line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code>var vm <span class=\"token operator\">=</span> new Vue<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  data:<span class=\"token punctuation\">{</span>\n    a:1\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n// <span class=\"token variable\"><span class=\"token variable\">`</span>vm.a<span class=\"token variable\">`</span></span> 是响应式的\n\nvm.b <span class=\"token operator\">=</span> 2\n// <span class=\"token variable\"><span class=\"token variable\">`</span>vm.b<span class=\"token variable\">`</span></span> 是非响应式的\n\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br><span class=\"line-number\">10</span><br><span class=\"line-number\">11</span><br></div><!--beforeend--></div><!--afterend--><h2 id=\"_019-什么是虚拟dom？为什么虚拟dom能提升性能\"><a class=\"header-anchor\" href=\"#_019-什么是虚拟dom？为什么虚拟dom能提升性能\" aria-hidden=\"true\">#</a> &amp;019. 什么是虚拟DOM？为什么虚拟DOM能提升性能</h2>\n<p>虚拟DOM就是一个JavaScript对象，通过这个JavaScript对象来描述真实DOM；</p>\n<p>真实DOM的操作，一般都会对某块元素的整体重新渲染</p>\n<p>采用虚拟DOM的话，当数据变化的时候，只需要局部刷新变化的位置就好了；虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分，最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗</p>\n<h2 id=\"_020-vue无法监听数组变化的情况\"><a class=\"header-anchor\" href=\"#_020-vue无法监听数组变化的情况\" aria-hidden=\"true\">#</a> &amp;020. vue无法监听数组变化的情况</h2>\n<ol>\n<li>利用索引值直接设置数组时</li>\n</ol>\n<p>解决：Vue.set 或者 vm.arr.splice</p>\n<ol start=\"2\">\n<li>修改数组的长度时</li>\n</ol>\n<p>解决：vm.items.splice(newLength)</p>\n<h2 id=\"_021-computed和watch的区别和运用的场景\"><a class=\"header-anchor\" href=\"#_021-computed和watch的区别和运用的场景\" aria-hidden=\"true\">#</a> &amp;021. computed和watch的区别和运用的场景</h2>\n<p>computed：计算属性，依赖于其他的属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值</p>\n<p>watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作</p>\n<p>场景：</p>\n<ol>\n<li>\n<p>需要进行数据计算，并且依赖于其他数据时；可以利用computed的缓存特性，避免每次获取值时，都要重新计算</p>\n</li>\n<li>\n<p>当数据变化时执行异步或开销较大的操作时，使用watch</p>\n</li>\n</ol>\n<h2 id=\"_022-vue-router路由模式有几种\"><a class=\"header-anchor\" href=\"#_022-vue-router路由模式有几种\" aria-hidden=\"true\">#</a> &amp;022. vue-router路由模式有几种</h2>\n<p>vue-router有3种路由模式：hash、history、abstract；</p>\n<p>hash：使用URL hash值来做路由，支持所有浏览器，包括不支持HTML5 History Api的浏览器</p>\n<ul>\n<li>hash值的改变，都会在浏览器的访问历史增加一个记录，因此我们能通过浏览器的回退、前进按钮控制hash的切换</li>\n<li>可以使用hashchange事件来监听hash值的变化，从而对页面进行跳转</li>\n</ul>\n<p>history：依赖HTML5 History API和服务器配置</p>\n<ul>\n<li>history.pushState()和history.replaceState()，这两个API可以在不进行刷新的情况下，操作浏览器的历史记录</li>\n</ul>\n</ContentSlotsDistributor>\n",null]}