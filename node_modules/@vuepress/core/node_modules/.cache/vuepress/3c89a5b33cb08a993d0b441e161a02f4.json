{"remainingRequest":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/@vuepress/markdown-loader/index.js??ref--1-2!/Users/xiaohanghang/Desktop/front/code/zh-doc/docs/VUE/Console/A001.md?vue&type=template&id=d4b682d4&","dependencies":[{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/docs/VUE/Console/A001.md","mtime":1581571682000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/cache-loader/dist/cjs.js","mtime":1581571682000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1581571684000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/cache-loader/dist/cjs.js","mtime":1581571682000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/vue-loader/lib/index.js","mtime":1581571684000},{"path":"/Users/xiaohanghang/Desktop/front/code/zh-doc/node_modules/@vuepress/markdown-loader/index.js","mtime":1581571682000}],"contextDependencies":[],"result":["\n<ContentSlotsDistributor :slot-key=\"$parent.slotKey\"><h1 id=\"a001-vue源码解析（一）-运行机制全局概览\"><a class=\"header-anchor\" href=\"#a001-vue源码解析（一）-运行机制全局概览\" aria-hidden=\"true\">#</a> A001_VUE源码解析（一） --运行机制全局概览#</h1>\n<div class=\"tip custom-block\"><p class=\"custom-block-title\">契子</p>\n<ul>\n<li>参考博文：https://www.cnblogs.com/tiedaweishao/p/8933153.html</li>\n<li>纸上得来终觉浅，绝知此事要躬行</li>\n<li>v-for key 是如何达到“就地复用”策略</li>\n<li>数组更新检测是如何完成的</li>\n<li>set 为什么就能动态添加根级别的响应式属性</li>\n<li>为什么Vue可以跨平台支持weex，以及后来出现的mpvue</li>\n</ul>\n</div>\n<h2 id=\"_01-init\"><a class=\"header-anchor\" href=\"#_01-init\" aria-hidden=\"true\">#</a> &amp;01._init</h2>\n<p>vue内部流程图：</p>\n<p><img src=\"./img/A001/vue.jpg\" alt=\"npm-script\"></p>\n<!--beforebegin--><div class=\"language-bash line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code>new Vue<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  el: <span class=\"token punctuation\">..</span>.,\n  data: <span class=\"token punctuation\">..</span>.,\n  <span class=\"token punctuation\">..</span><span class=\"token punctuation\">..</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br></div><!--beforeend--></div><!--afterend--><p>new Vue() =&gt; _init():进行一系列的初始化，生命周期/props等</p>\n<p>Object.defineProperty(): vue通过调用Object.defineProperty对data实行getter和setter操作，实现数据和视图的联动\nhttps://www.jianshu.com/p/8fe1382ba135</p>\n<p>javacript 有三种类型的属性</p>\n<p>1.命名数据属性：拥有一个确定的值的属性。这也是最常见的属性</p>\n<p>2.命名访问器属性：通过getter和setter进行读取和赋值的属性</p>\n<p>3.内部属性：由JavaScript引擎内部使用的属性，不能通过JavaScript代码直接访问到，不过可以通过一些方法间接的读取和设置。比如，每个对象都有一个内部属性[[Prototype]]，你不能直接访问这个属性，但可以通过Object.getPrototypeOf()方法间接的读取到它的值。虽然内部属性通常用一个双吕括号包围的名称来表示，但实际上这并不是它们的名字，它们是一种抽象操作，是不可见的，根本没有上面两种属性有的那种字符串类型的属性</p>\n<h2 id=\"_02-编译\"><a class=\"header-anchor\" href=\"#_02-编译\" aria-hidden=\"true\">#</a> &amp;02.编译</h2>\n<p>compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。</p>\n<h2 id=\"_03-响应式\"><a class=\"header-anchor\" href=\"#_03-响应式\" aria-hidden=\"true\">#</a> &amp;03.响应式</h2>\n<p>vue在初始化的时候，会通过Object.defineProperty()的getter()和setter()函数对data进行绑定。当被设置的对象被读取的时候，会执行getter函数，当被设置的对象被设置的时候，会执行setter函数。触发getter函数的时候，会有一个【依赖收集】，会将数据放到一个watch队列里面，当有数据发生改变的时候，会触发setter函数，setter会通知watch队列，进而进行update，触发视图重新渲染</p>\n<h2 id=\"_04-virtual-dom\"><a class=\"header-anchor\" href=\"#_04-virtual-dom\" aria-hidden=\"true\">#</a> &amp;04.Virtual DOM</h2>\n<p>render function 会被转化成vnode节点，实际上vue中的虚拟树就是一棵以JavaScript对象（VNode）作为基础的树，用对象属性来描述节点，实际上它只是一层对dom节点的抽象。最终可以通过一系列操作使这棵树映射到真实的环境上，因此具有跨平台的能力。</p>\n<!--beforebegin--><div class=\"language-bash line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-bash\"><code><span class=\"token punctuation\">{</span>\n    tag: <span class=\"token string\">'div'</span>,                 /*说明这是一个div标签*/\n    children: <span class=\"token punctuation\">[</span>                 /*存放该标签的子节点*/\n        <span class=\"token punctuation\">{</span>\n            tag: <span class=\"token string\">'a'</span>,           /*说明这是一个a标签*/\n            text: <span class=\"token string\">'click me'</span>    /*标签的内容*/\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br><span class=\"line-number\">4</span><br><span class=\"line-number\">5</span><br><span class=\"line-number\">6</span><br><span class=\"line-number\">7</span><br><span class=\"line-number\">8</span><br><span class=\"line-number\">9</span><br></div><!--beforeend--></div><!--afterend--><h2 id=\"_05-更新视图\"><a class=\"header-anchor\" href=\"#_05-更新视图\" aria-hidden=\"true\">#</a> &amp;05.更新视图</h2>\n<p>在修改一个对象的值时，会通过setter=》watcher=》update流程来修改对应的视图。如果一个值的修改完之后，生成新的vnode，再进行比较差异，替换全部的节点数--diff算法</p>\n</ContentSlotsDistributor>\n",null]}